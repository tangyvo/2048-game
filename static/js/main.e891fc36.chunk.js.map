{"version":3,"sources":["component/Gameover.jsx","component/Header.jsx","component/Instructions.jsx","component/Grid.jsx","App.js","index.js"],"names":["Gameover","gameover","score","className","Header","bestScore","init","onClick","Instructions","Grid","grid","id","join","split","map","tile","index","key","App","useState","setBestScore","setScore","newTile","setNewtile","setGameover","tileToggle","setTileToggle","newTileId","setNewTileId","touchStart","setTouchStart","touchMove","setTouchMove","touchEnd","setTouchEnd","setGrid","useEffect","localStorage","getItem","randTile","randIndex","Math","round","random","prev","gridCopy","empty","row","floor","col","getTileId","calcTotalScore","r","c","total","reduce","cur","Number","swipe","e","isBrowser","JSON","parse","stringify","num","filter","checkMerge","i","undefined","moveUp","moveDown","moveLeft","reverse","moveRight","change","j","checkGameOver","length","noMatch","setItem","array","newArray","splice","window","addEventListener","removeEventListener","changeX","changeY","absChangeX","abs","absChangeY","touchType","type","touches","clientX","clientY","onTouchStart","onTouchMove","onTouchEnd","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e891fc36.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Gameover = ({ gameover, score }) => {\n  return (\n    <div className={gameover ? \"gameover show\" : \"gameover\"}>\n      <p>{score >= 2048 ? `You've won` : `No more moves`}</p>\n    </div>\n  );\n};\n\nexport default Gameover;\n","import React from \"react\";\n\n\nconst Header = ({ score, bestScore, init }) => {\n  return (\n    <>\n      <header>\n        <div className=\"logo\">\n          <p>2048</p>\n        </div>\n        <div className=\"header-info-section\">\n          <div className=\"score\">\n            <p>score</p>\n            <p>{score}</p>\n          </div>\n          <div className=\"best\">\n            <p>Best</p>\n            <p>{bestScore}</p>\n          </div>\n          <button className=\"btn btn-reset\" onClick={init}>\n            Reset\n          </button>\n        </div>\n      </header>\n\n\n    </>\n  );\n};\n\nexport default Header;\n","import React from 'react';\n\nexport default function Instructions() {\n  return (\n    <div className='instructions'>\n          <strong>How to play: </strong>Press the ↑, ↓, →, ← arrow keys\n      to move the tiles. When 2 same tiles touch they merge into one. Reach 2048\n      to win.\n    </div>\n  );\n}\n","import React from \"react\";\n\nconst Grid = ({ grid, id }) => {\n  return (\n    <main className=\"grid\">\n        \n      {grid\n        .join(\",\")\n        .split(\",\")\n        .map((tile, index) => (\n          <div className={`colour-${tile} ${index === id ? 'newBlock' : ''}`} key={index}>\n            {tile === \"0\" ? \"\" : tile}\n          </div>\n        ))}\n    </main>\n  );\n};\n\nexport default Grid;\n","import React, { useState, useEffect } from 'react';\nimport { isBrowser } from 'react-device-detect';\nimport GameOver from './component/Gameover';\nimport Header from './component/Header';\nimport Instructions from './component/Instructions';\nimport Grid from './component/Grid';\n\nfunction App() {\n  const LOCALSTORAGE_KEY = '2048-best-score';\n  const [bestScore, setBestScore] = useState(0);\n  const [score, setScore] = useState(0);\n  const [newTile, setNewtile] = useState(0);\n  const [gameover, setGameover] = useState(false);\n  const [tileToggle, setTileToggle] = useState(false);\n  const [newTileId, setNewTileId] = useState();\n  const [touchStart, setTouchStart] = useState([0, 0]);\n  const [touchMove, setTouchMove] = useState([0, 0]);\n  const [touchEnd, setTouchEnd] = useState(false);\n  const [grid, setGrid] = useState([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ]);\n\n  useEffect(() => {\n    // get best score if there is one, else set to 0.\n    let bestScore = localStorage.getItem(LOCALSTORAGE_KEY)\n      ? localStorage.getItem(LOCALSTORAGE_KEY)\n      : 0;\n    setBestScore(bestScore);\n\n    randTile();\n  }, []);\n\n  const randTile = () => {\n    // generate random 2/4 tile.\n    const num = [2, 4];\n    const randIndex = Math.round(Math.random());\n    setNewtile(num[randIndex]);\n\n    // used to track a new tile was generated even if its the same as the prev\n    setTileToggle((prev) => (prev === true ? false : true));\n  };\n\n  useEffect(() => {\n    const gridCopy = [...grid];\n    let empty = false;\n\n    // generate rand grid pos (x,y) if its empty insert new tile\n    while (!empty) {\n      let row = Math.floor(Math.random() * 4);\n      let col = Math.floor(Math.random() * 4);\n      if (gridCopy[row][col] === 0) {\n        gridCopy[row][col] = newTile;\n        getTileId(row, col);\n        empty = true;\n        calcTotalScore();\n      }\n    }\n    setGrid(gridCopy);\n  }, [tileToggle]);\n\n  // set new tile + convert from (x,y) to ID\n  const getTileId = (r, c) => {\n    let pos = r * 4 + c;\n    setNewTileId(pos);\n  };\n\n  // reset everything\n  const init = () => {\n    setGrid([\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ]);\n    randTile();\n    setScore(newTile);\n    setGameover(false);\n  };\n\n  // if current score is best score save to local storage\n  const saveBestScore = () => {\n    if (score > bestScore) {\n      localStorage.setItem(LOCALSTORAGE_KEY, score);\n      setBestScore(score);\n    }\n  };\n\n  // count total points on grid\n  const calcTotalScore = () => {\n    let total = 0;\n    grid.map(\n      (row) => (total += row.reduce((prev, cur) => prev + Number(cur), 0))\n    );\n    setScore(total);\n  };\n\n  // set new grid when swipe UP\n  const moveUp = () => {\n    let gridCopy = [...grid];\n    for (let col = 0; col < 4; col++) {\n      let column = [0, 1, 2, 3].map((num) => gridCopy[num][col]);\n      let tile = column.filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[i][col] = tile[i] !== undefined ? tile[i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // set new grid when swipe DOWN\n  const moveDown = () => {\n    let gridCopy = [...grid];\n    for (let col = 0; col < 4; col++) {\n      let column = [3, 2, 1, 0].map((num) => gridCopy[num][col]);\n      let tile = column.filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[i][col] = tile[3 - i] !== undefined ? tile[3 - i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // set new grid when swipe RIGHT\n  const moveRight = () => {\n    let gridCopy = [...grid];\n    for (let row = 0; row < 4; row++) {\n      let tile = gridCopy[row].filter((num) => num > 0);\n      tile = checkMerge(tile).reverse();\n      for (let i = 0; i < 4; i++) {\n        gridCopy[row][i] = tile[3 - i] !== undefined ? tile[3 - i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // set new grid when swipe LEFT\n  const moveLeft = () => {\n    let gridCopy = [...grid];\n    for (let row = 0; row < 4; row++) {\n      let tile = gridCopy[row].filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[row][i] = tile[i] !== undefined ? tile[i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // call when keypress/mobile swipe\n  const swipe = (e) => {\n    if (isBrowser) {\n      e = e.key;\n    }\n\n    // make deep copy of prev grid state\n    const prev = JSON.parse(JSON.stringify([...grid]));\n\n    if (e === 'ArrowUp') {\n      moveUp();\n    } else if (e === 'ArrowDown') {\n      moveDown();\n    } else if (e === 'ArrowLeft') {\n      moveLeft();\n    } else if (e === 'ArrowRight') {\n      moveRight();\n    } else {\n      return;\n    }\n\n    // check if grid changed after keypress/swipe\n    let change = false;\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        if (prev[i][j] !== grid[i][j]) {\n          change = true;\n        }\n      }\n    }\n\n    // if grid change then add new tile, calc score and check if gameover\n    if (change) {\n      randTile();\n      calcTotalScore();\n      checkGameOver();\n    }\n  };\n\n  const checkGameOver = () => {\n    // check no tiles are empty\n    let empty = 0;\n    for (let row of grid) {\n      empty += row.filter((col) => col !== 0).length;\n    }\n    if (empty !== 16) return;\n\n    // check if there are any touching tiles with same number\n    let noMatch = true;\n    for (let row = 0; row <= 3; row++) {\n      for (let col = 0; col <= 3; col++) {\n        if (row === 3) {\n          if (grid[row][col] === grid[row][col + 1]) {\n            noMatch = false;\n          }\n        } else if (col === 3) {\n          if (grid[row][col] === grid[row + 1][col]) {\n            noMatch = false;\n          }\n        } else if (\n          grid[row][col] === grid[row + 1][col] ||\n          grid[row][col] === grid[row][col + 1]\n        ) {\n          noMatch = false;\n        }\n      }\n    }\n\n    // gameover and store best score\n    if (noMatch) {\n      setGameover(true);\n      saveBestScore();\n    }\n  };\n\n  const checkMerge = (array) => {\n    let newArray = [...array];\n    for (let i = 0; i < array.length - 1; i++) {\n      // check if array contains same tile next to each other\n      if (newArray[i] === newArray[i + 1]) {\n        // if so, double tile and remove from 1 from array\n        newArray[i] = array[i] * 2;\n        newArray.splice(i + 1, 1);\n      }\n    }\n    return newArray;\n  };\n\n  // add and remove event listeners\n  useEffect(() => {\n    if (!gameover) {\n      window.addEventListener('keydown', swipe);\n      return () => {\n        window.removeEventListener('keydown', swipe);\n      };\n    }\n  });\n\n  // called when mobile swipe detected\n  useEffect(() => {\n    if (!touchEnd) return;\n    // compare touchstart and touchend to determine up, down, left or right swipe\n    let changeX = touchStart[0] - touchMove[0];\n    let changeY = touchStart[1] - touchMove[1];\n    let absChangeX = Math.abs(changeX);\n    let absChangeY = Math.abs(changeY);\n\n    // left/right swipe\n    if (absChangeX > absChangeY) {\n      if (changeX > 0) {\n        swipe('ArrowLeft');\n      } else {\n        swipe('ArrowRight');\n      }\n    }\n    // up/down swipe\n    else if (absChangeX < absChangeY) {\n      if (changeY > 0) {\n        swipe('ArrowUp');\n      } else {\n        swipe('ArrowDown');\n      }\n    }\n    setTouchEnd(false);\n  }, [touchEnd]);\n\n  const touchType = (e) => {\n    if (e.type === 'touchstart') {\n      setTouchStart([e.touches[0].clientX, e.touches[0].clientY]);\n    } else if (e.type === 'touchmove') {\n      setTouchMove([e.touches[0].clientX, e.touches[0].clientY]);\n    } else if (e.type === 'touchend') {\n      setTouchEnd(true);\n    }\n  };\n\n  return (\n    <div\n      className='app'\n      onTouchStart={(e) => touchType(e)}\n      onTouchMove={(e) => touchType(e)}\n      onTouchEnd={(e) => touchType(e)}\n    >\n      <Header score={score} bestScore={bestScore} init={init} />\n      <Instructions />\n      <GameOver className='gameover' gameover={gameover} score={score} />\n      <Grid grid={grid} id={newTileId} />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}