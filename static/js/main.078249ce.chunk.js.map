{"version":3,"sources":["component/Gameover.jsx","component/Header.jsx","component/Grid.jsx","App.js","index.js"],"names":["Gameover","gameover","score","className","Header","bestScore","init","Fragment","onClick","Grid","grid","id","join","split","map","tile","index","key","App","useState","setBestScore","setScore","newTile","setNewtile","setGameover","tileToggle","settileToggle","newTileId","setNewTileId","setGrid","useEffect","localStorage","getItem","randTile","gridCopy","empty","row","Math","floor","random","col","getTileId","calcTotal","r","c","prev","randIndex","round","total","reduce","cur","Number","swipe","e","JSON","parse","stringify","num","filter","checkMerge","i","undefined","moveUp","moveDown","moveLeft","reverse","moveRight","change","j","checkGameOver","length","noMatch","setItem","array","newArray","splice","window","addEventListener","removeEventListener","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.078249ce.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Gameover = ({ gameover, score }) => {\n  return (\n    <div className={gameover ? \"gameover show\" : \"gameover\"}>\n      <p>{score >= 2048 ? `You've won` : `No more moves`}</p>\n    </div>\n  );\n};\n\nexport default Gameover;\n","import React from \"react\";\n\nconst Header = ({ score, bestScore, init }) => {\n  return (\n    <React.Fragment>\n      <header>\n        <div className=\"logo\">\n          <p>2048</p>\n        </div>\n        <div className=\"header-info-section\">\n          <div className=\"score\">\n            <p>score</p>\n            <p>{score}</p>\n          </div>\n          <div className=\"best\">\n            <p>Best</p>\n            <p>{bestScore}</p>\n          </div>\n          <button className=\"btn btn-reset\" onClick={init}>\n            Reset\n          </button>\n        </div>\n      </header>\n\n      <div className=\"instructions\">\n        <strong>How to play: </strong>Press the up, down, right or left arrow\n        keys to move the tiles. When 2 same tiles touch they merge into one.\n        Reach 2048 to win.\n      </div>\n    </React.Fragment>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\n\nconst Grid = ({ grid, id }) => {\n  return (\n    <main className=\"grid\">\n        \n      {grid\n        .join(\",\")\n        .split(\",\")\n        .map((tile, index) => (\n          <div className={`colour-${tile} ${index === id ? 'newBlock' : ''}`} key={index}>\n            {tile === \"0\" ? \"\" : tile}\n          </div>\n        ))}\n    </main>\n  );\n};\n\nexport default Grid;\n","import React, { useState, useEffect } from \"react\";\nimport GameOver from \"./component/Gameover\";\nimport Header from \"./component/Header\";\nimport Grid from \"./component/Grid\";\n\nfunction App() {\n  const LOCALSTORAGE_KEY = \"2048-best-score\";\n  const [bestScore, setBestScore] = useState(0);\n  const [score, setScore] = useState(0);\n  const [newTile, setNewtile] = useState(0);\n  const [gameover, setGameover] = useState(false);\n  const [tileToggle, settileToggle] = useState(false);\n  const [newTileId, setNewTileId] = useState();\n  const [grid, setGrid] = useState([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ]);\n\n  // PAGE LOAD - GET BESTSCORE AND FIRST TILE\n  useEffect(() => {\n    setBestScore(localStorage.getItem(LOCALSTORAGE_KEY));\n    randTile();\n  }, []);\n\n  // ADD NEW TILE\n  useEffect(() => {\n    const gridCopy = [...grid];\n    let empty = false;\n\n    // KEEP LOOPING UNTIL EMPTY BLOCK FOUND\n    while (!empty) {\n      let row = Math.floor(Math.random() * 4);\n      let col = Math.floor(Math.random() * 4);\n      if (gridCopy[row][col] === 0) {\n        gridCopy[row][col] = newTile;\n        getTileId(row, col);\n        empty = true;\n        calcTotal();\n      }\n    }\n    setGrid(gridCopy);\n  }, [tileToggle]);\n\n  // GET POSITION ON GRID E.G. ROW 1, COL 1 = POSITION 5\n  const getTileId = (r, c) => {\n    let pos = r * 4 + c;\n    setNewTileId(pos);\n  };\n\n  // RESET GRID ARRAY, CURRENT SCORE AND RESET GAMEOVER STATE\n  const init = () => {\n    setGrid([\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ]);\n    randTile();\n    setScore(newTile);\n    setGameover(false);\n  };\n\n  // FN TO CHECK IF SCORE IS A BEST SCORE AND SAVE TO LOCAL STORAGE\n  const saveBestScore = () => {\n    if (score > bestScore) {\n      localStorage.setItem(LOCALSTORAGE_KEY, score);\n      setBestScore(score);\n    }\n  };\n\n  // GENERATE NEW RANDOM 2 OR 4 TILE\n  const randTile = () => {\n    settileToggle((prev) => (prev === true ? false : true));\n    const num = [2, 4];\n    const randIndex = Math.round(Math.random());\n    setNewtile(num[randIndex]);\n  };\n\n  // COUNT TOTAL POINTS ON GRID\n  const calcTotal = () => {\n    let total = 0;\n    grid.map(\n      (row) => (total += row.reduce((prev, cur) => prev + Number(cur), 0))\n    );\n    setScore(total);\n  };\n\n  // CALCULATE NEW GRID POSITIONS WHEN 'UP' KEY PRESSED\n  const moveUp = () => {\n    let gridCopy = [...grid];\n    for (let col = 0; col < 4; col++) {\n      let column = [0, 1, 2, 3].map((num) => gridCopy[num][col]);\n      let tile = column.filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[i][col] = tile[i] !== undefined ? tile[i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // CALCULATE NEW GRID POSITIONS WHEN 'DOWN' KEY PRESSED\n  const moveDown = () => {\n    let gridCopy = [...grid];\n    for (let col = 0; col < 4; col++) {\n      let column = [3, 2, 1, 0].map((num) => gridCopy[num][col]);\n      let tile = column.filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[i][col] = tile[3 - i] !== undefined ? tile[3 - i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // CALCULATE NEW GRID POSITIONS WHEN 'RIGHT' KEY PRESSED\n  const moveRight = () => {\n    let gridCopy = [...grid];\n    for (let row = 0; row < 4; row++) {\n      let tile = gridCopy[row].filter((num) => num > 0);\n      tile = checkMerge(tile).reverse();\n      for (let i = 0; i < 4; i++) {\n        gridCopy[row][i] = tile[3 - i] !== undefined ? tile[3 - i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // CALCULATE NEW GRID POSITIONS WHEN 'LEFT' KEY PRESSED\n  const moveLeft = () => {\n    let gridCopy = [...grid];\n    for (let row = 0; row < 4; row++) {\n      let tile = gridCopy[row].filter((num) => num > 0);\n      tile = checkMerge(tile);\n      for (let i = 0; i < 4; i++) {\n        gridCopy[row][i] = tile[i] !== undefined ? tile[i] : 0;\n      }\n    }\n    setGrid(gridCopy);\n  };\n\n  // CALL FN DEPENDING ON KEY PRESSED\n  const swipe = (e) => {\n    // DEEP COPY \n    const prev = JSON.parse(JSON.stringify([...grid]));\n    if (e.key === \"ArrowUp\") {\n      moveUp();\n    } else if (e.key === \"ArrowDown\") {\n      moveDown();\n    } else if (e.key === \"ArrowLeft\") {\n      moveLeft();\n    } else if (e.key === \"ArrowRight\") {\n      moveRight();\n    } else {\n      return;\n    }\n    // COMPARE PREVIOUS GRID STATE TO CURRENT TO SEE IF THERE WAS A CHANGE\n    let change = false;\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        if (prev[i][j] !== grid[i][j]) {\n          change = true;\n        }\n      }\n    }\n\n    // ONLY RENDER NEW TILE CALCULATE TOTAL FN IF GRID CHANGED \n    if (change) {\n      randTile();\n      calcTotal();\n    }\n  };\n\n  // CHECK IF GAME IS OVER EVERY TIME GRID IS UPDATED\n  useEffect(() => {\n    checkGameOver();\n  }, [grid]);\n\n  // FN TO CHECK IF GAME IS OVER\n  const checkGameOver = () => {\n    // CHECK NO TILES ARE EMPTY\n    let empty = 0;\n    for (let row of grid) {\n      empty += row.filter((col) => col !== 0).length;\n    }\n    if (empty !== 16) return;\n\n    // SET noMatch TO FALSE IF TILE IS THE SAME AS THE ONE NEXT TO IT (THEREFORE GAME IS NOT OVER)\n    let noMatch = true;\n    for (let row = 0; row <= 3; row++) {\n      for (let col = 0; col <= 3; col++) {\n        if (row === 3) {\n          if (grid[row][col] === grid[row][col + 1]) {\n            noMatch = false;\n          }\n        } else if (col === 3) {\n          if (grid[row][col] === grid[row + 1][col]) {\n            noMatch = false;\n          }\n        } else if (\n          grid[row][col] === grid[row + 1][col] ||\n          grid[row][col] === grid[row][col + 1]\n        ) {\n          noMatch = false;\n        }\n      }\n    }\n\n    // SET GAMEOVER AND CHECK BEST SCORE ONLY IF THERE ARE NO MATCHES FOUND ON GRID\n    if (noMatch) {\n      setGameover(true);\n      saveBestScore();\n    }\n  };\n\n  // MERGE 2 TILES BY DOUBLING AND THEN REMOVING 2ND FILE FROM ARRAY\n  const checkMerge = (array) => {\n    let newArray = [...array];\n    for (let i = 0; i < array.length - 1; i++) {\n      if (newArray[i] === newArray[i + 1]) {\n        newArray[i] = array[i] * 2;\n        newArray.splice(i + 1, 1);\n      }\n    }\n    return newArray;\n  };\n\n  // ADD AND REMOVE EVENT LISTENERS\n  useEffect(() => {\n    if (!gameover) {\n      window.addEventListener(\"keydown\", swipe);\n      return () => {\n        window.removeEventListener(\"keydown\", swipe);\n      };\n    }\n  });\n\n  return (\n    <div className=\"app\">\n      <Header score={score} bestScore={bestScore} init={init} />\n      <GameOver className=\"gameover\" gameover={gameover} score={score} />\n      <Grid grid={grid} id={newTileId} />\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}